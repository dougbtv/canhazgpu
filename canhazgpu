#!/usr/bin/env python

import os
import sys
import time
import json
import click
import redis
import subprocess
import threading
import random
import re
import csv
import pwd
from io import StringIO

REDIS_KEY_PREFIX = 'canhazgpu:'
ALLOCATION_LOCK_KEY = f'{REDIS_KEY_PREFIX}allocation_lock'
LOCK_TIMEOUT = 10  # seconds
MAX_RETRIES = 5
MEMORY_THRESHOLD_MB = 100  # Consider GPU in use if memory > 100MB


def get_redis():
    return redis.Redis(host='localhost', port=6379, db=0)


def now_ts():
    return int(time.time())


def get_username():
    return os.getenv('USER', 'unknown')


def format_duration(seconds):
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    return f"{hours}h {minutes}m {seconds}s"


def parse_duration(duration_str):
    """Parse duration string like '2h', '30m', '1d' into seconds."""
    if not duration_str:
        return 8 * 3600  # 8 hours default
    
    # Match number followed by unit (h, m, d)
    match = re.match(r'^(\d+(?:\.\d+)?)\s*([hmd])$', duration_str.lower().strip())
    if not match:
        raise click.BadParameter(f"Invalid duration format: {duration_str}. Use format like '2h', '30m', or '1d'")
    
    value, unit = match.groups()
    value = float(value)
    
    if unit == 'h':
        return int(value * 3600)
    elif unit == 'm':
        return int(value * 60)
    elif unit == 'd':
        return int(value * 24 * 3600)
    
    raise click.BadParameter(f"Unknown time unit: {unit}")


def format_expiry_time(expiry_ts):
    """Format expiry timestamp for display."""
    now = now_ts()
    if expiry_ts <= now:
        return "EXPIRED"
    
    remaining = expiry_ts - now
    return f"expires in {format_duration(remaining)}"


def get_process_owner(pid):
    """Get the username of the process owner."""
    try:
        # Try to get process info from /proc filesystem
        with open(f'/proc/{pid}/status', 'r') as f:
            for line in f:
                if line.startswith('Uid:'):
                    # Get the real UID (first number after Uid:)
                    uid = int(line.split()[1])
                    return pwd.getpwuid(uid).pw_name
    except (FileNotFoundError, PermissionError, ValueError, KeyError, IndexError):
        # Fallback to ps command if /proc is not accessible
        try:
            result = subprocess.run(['ps', '-o', 'user=', '-p', str(pid)], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
            pass
    
    return "unknown"


def detect_gpu_usage():
    """Detect actual GPU usage using nvidia-smi."""
    try:
        # Query compute processes
        result = subprocess.run([
            'nvidia-smi', 
            '--query-compute-apps=gpu_bus_id,pid,process_name,used_memory',
            '--format=csv,noheader,nounits'
        ], capture_output=True, text=True, timeout=10)
        
        if result.returncode != 0:
            return {}
        
        # Parse CSV output
        gpu_processes = {}
        if result.stdout.strip():
            csv_reader = csv.reader(StringIO(result.stdout))
            for row in csv_reader:
                if len(row) >= 4:
                    bus_id, pid, process_name, memory_mb = [col.strip() for col in row]
                    if bus_id not in gpu_processes:
                        gpu_processes[bus_id] = []
                    
                    # Get process owner
                    owner = get_process_owner(pid)
                    
                    gpu_processes[bus_id].append({
                        'pid': pid,
                        'process_name': process_name,
                        'memory_mb': int(memory_mb) if memory_mb.isdigit() else 0,
                        'owner': owner
                    })
        
        # Query GPU info to map bus IDs to GPU indices
        result = subprocess.run([
            'nvidia-smi',
            '--query-gpu=index,pci.bus_id,memory.used',
            '--format=csv,noheader,nounits'
        ], capture_output=True, text=True, timeout=10)
        
        if result.returncode != 0:
            return {}
        
        gpu_usage = {}
        if result.stdout.strip():
            csv_reader = csv.reader(StringIO(result.stdout))
            for row in csv_reader:
                if len(row) >= 3:
                    gpu_index, bus_id, memory_used = [col.strip() for col in row]
                    gpu_id = int(gpu_index)
                    memory_mb = int(memory_used) if memory_used.isdigit() else 0
                    
                    processes = gpu_processes.get(bus_id, [])
                    
                    # Consider GPU in use if:
                    # 1. Has compute processes, OR
                    # 2. Memory usage exceeds threshold
                    in_use = len(processes) > 0 or memory_mb > MEMORY_THRESHOLD_MB
                    
                    gpu_usage[gpu_id] = {
                        'in_use': in_use,
                        'processes': processes,
                        'memory_mb': memory_mb,
                        'bus_id': bus_id
                    }
        
        return gpu_usage
        
    except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
        # nvidia-smi not available or failed - return empty dict
        return {}


def acquire_allocation_lock(r, lock_id):
    """Acquire global allocation lock with retry and exponential backoff."""
    for attempt in range(MAX_RETRIES):
        # Try to acquire lock with SET NX EX
        if r.set(ALLOCATION_LOCK_KEY, lock_id, nx=True, ex=LOCK_TIMEOUT):
            return True
        
        # Exponential backoff with jitter
        wait_time = (2 ** attempt) * 0.1 + random.uniform(0, 0.1)
        time.sleep(wait_time)
    
    return False


def release_allocation_lock(r, lock_id):
    """Release allocation lock only if we own it."""
    # Lua script for atomic check-and-delete
    lua_script = """
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    """
    return r.eval(lua_script, 1, ALLOCATION_LOCK_KEY, lock_id)


@click.group()
def cli():
    pass


@cli.command()
@click.option('--gpus', required=True, type=int, help='Number of GPUs available on this machine')
@click.option('--force', is_flag=True, help='Force reinitialization even if already initialized')
def admin(gpus, force):
    """Initialize GPU pool for this machine.
    
    Examples:
        canhazgpu admin --gpus 8
        canhazgpu admin --gpus 4 --force
    """
    r = get_redis()
    
    # Check if already initialized
    existing_count = r.get(f'{REDIS_KEY_PREFIX}gpu_count')
    if existing_count and not force:
        existing_count = int(existing_count)
        click.echo(f"Warning: GPU pool already initialized with {existing_count} GPUs.", err=True)
        click.echo("Use --force to override and reinitialize.", err=True)
        sys.exit(1)
    
    # Clean up any existing GPU reservations if reinitializing
    if existing_count and force:
        existing_count = int(existing_count)
        click.echo(f"Force reinitializing: clearing {existing_count} existing GPUs...")
        for gpu_id in range(existing_count):
            r.delete(f'{REDIS_KEY_PREFIX}gpu:{gpu_id}')
    
    # Initialize new GPU pool with initial last_released timestamp
    init_time = now_ts()
    for gpu_id in range(gpus):
        r.set(f'{REDIS_KEY_PREFIX}gpu:{gpu_id}', json.dumps({'last_released': init_time}))
    r.set(f'{REDIS_KEY_PREFIX}gpu_count', gpus)
    
    if existing_count and force:
        click.echo(f"Reinitialized {gpus} GPUs (IDs 0 to {gpus - 1})")
    else:
        click.echo(f"Initialized {gpus} GPUs (IDs 0 to {gpus - 1})")


@cli.command()
def status():
    """Show current GPU allocation status with automatic validation.
    
    Example: canhazgpu status
    """
    r = get_redis()
    gpu_count = int(r.get(f'{REDIS_KEY_PREFIX}gpu_count') or 0)
    now = now_ts()
    
    # Always get actual GPU usage for validation
    actual_usage = detect_gpu_usage()
    validation_available = bool(actual_usage)
    
    if not validation_available:
        click.echo("Warning: Could not detect GPU usage (nvidia-smi unavailable)", err=True)
    
    for gpu_id in range(gpu_count):
        data = r.get(f'{REDIS_KEY_PREFIX}gpu:{gpu_id}')
        reservation_entry = json.loads(data) if data else {}
        
        # Check reservation status
        has_reservation = reservation_entry and reservation_entry.get('user')
        
        # Check actual usage
        actual_in_use = actual_usage.get(gpu_id, {}).get('in_use', False)
        processes = actual_usage.get(gpu_id, {}).get('processes', [])
        memory_mb = actual_usage.get(gpu_id, {}).get('memory_mb', 0)
        
        if has_reservation:
            user = reservation_entry.get('user')
            start = reservation_entry.get('start_time')
            reservation_type = reservation_entry.get('type', 'run')
            age = now - start if start else 0
            
            status_line = f"GPU {gpu_id}: IN USE by {user} for {format_duration(age)}"
            
            if reservation_type == 'manual' and reservation_entry.get('expiry_time'):
                expiry_info = format_expiry_time(reservation_entry['expiry_time'])
                status_line += f" (manual, {expiry_info})"
            else:
                heartbeat = reservation_entry.get('last_heartbeat')
                hb_age = now - heartbeat if heartbeat else 0
                status_line += f" (run, last heartbeat {format_duration(hb_age)} ago)"
            
            # Add validation info if available
            if validation_available:
                if actual_in_use:
                    status_line += f" [validated: {memory_mb}MB, {len(processes)} processes]"
                else:
                    status_line += " [validated: no actual usage detected]"
            
            click.echo(status_line)
            
        elif actual_in_use and validation_available:
            # GPU shows as available but is actually in use
            process_info = []
            users = set()
            
            for proc in processes[:2]:  # Show first 2 processes
                owner = proc.get('owner', 'unknown')
                users.add(owner)
                process_info.append(f"PID {proc['pid']} ({proc['process_name']})")
            
            process_str = ", ".join(process_info)
            if len(processes) > 2:
                process_str += f" and {len(processes) - 2} more"
            
            # Format user information
            if len(users) == 1:
                user_str = f"user {list(users)[0]}"
            else:
                user_list = sorted(list(users))
                if 'unknown' in user_list:
                    user_list.remove('unknown')
                    user_list.append('unknown')
                if len(user_list) == 1:
                    user_str = f"user {user_list[0]}"
                elif len(user_list) == 2:
                    user_str = f"users {user_list[0]} and {user_list[1]}"
                else:
                    user_str = f"users {', '.join(user_list[:-1])} and {user_list[-1]}"
                
            click.echo(f"GPU {gpu_id}: IN USE WITHOUT RESERVATION by {user_str} - {memory_mb}MB used by {process_str}")
            
        else:
            # Available GPU - show last released time if available
            last_released = reservation_entry.get('last_released')
            status_line = f"GPU {gpu_id}: AVAILABLE"
            
            if last_released:
                time_since_release = now - last_released
                status_line += f" (last released {format_duration(time_since_release)} ago)"
            
            # Add validation info if available and memory is being used
            if validation_available and memory_mb > 0:
                status_line += f" [validated: {memory_mb}MB used]"
            
            click.echo(status_line)


def rollback_reservations(r, reserved_gpus):
    """Rollback GPU reservations by clearing their state and recording release time."""
    release_time = now_ts()
    for gpu_id in reserved_gpus:
        key = f'{REDIS_KEY_PREFIX}gpu:{gpu_id}'
        r.set(key, json.dumps({'last_released': release_time}))


def get_available_gpus_sorted_by_lru(r, exclude_unauthorized=True):
    """Get available GPUs sorted by least recently used (oldest last_released first)."""
    gpu_count = int(r.get(f'{REDIS_KEY_PREFIX}gpu_count') or 0)
    now = now_ts()
    available_gpus = []
    
    # Get actual GPU usage to exclude unauthorized usage
    unauthorized_gpus = set()
    if exclude_unauthorized:
        actual_usage = detect_gpu_usage()
        for gpu_id, usage_info in actual_usage.items():
            if usage_info.get('in_use', False):
                # Check if this GPU has a valid reservation
                key = f'{REDIS_KEY_PREFIX}gpu:{gpu_id}'
                data = r.get(key)
                if data:
                    entry = json.loads(data)
                    if not entry or not is_gpu_reserved(entry, now):
                        # GPU is in use but not reserved - exclude it
                        unauthorized_gpus.add(gpu_id)
                else:
                    # No reservation data but GPU is in use - exclude it
                    unauthorized_gpus.add(gpu_id)
    
    for gpu_id in range(gpu_count):
        # Skip GPUs that are in use without authorization
        if gpu_id in unauthorized_gpus:
            continue
            
        key = f'{REDIS_KEY_PREFIX}gpu:{gpu_id}'
        data = r.get(key)
        
        if data:
            entry = json.loads(data)
            if not entry or not is_gpu_reserved(entry, now):
                # GPU is available - get last_released time
                last_released = entry.get('last_released', 0) if entry else 0
                available_gpus.append((gpu_id, last_released))
        else:
            # No data means never used - highest priority (oldest timestamp = 0)
            available_gpus.append((gpu_id, 0))
    
    # Sort by last_released time (oldest first - LRU)
    available_gpus.sort(key=lambda x: x[1])
    return [gpu_id for gpu_id, _ in available_gpus]


def atomic_reserve_gpus(r, count, user, reservation_type='run', expiry_time=None):
    """Atomically reserve GPUs using Redis SET NX operations with LRU selection and validation."""
    now = now_ts()
    reserved = []
    
    reservation_data = {
        'user': user,
        'start_time': now,
        'last_heartbeat': now,
        'type': reservation_type
    }
    
    if expiry_time:
        reservation_data['expiry_time'] = expiry_time
    
    reservation_json = json.dumps(reservation_data)
    
    # Get available GPUs sorted by LRU, excluding those in unauthorized use
    available_gpu_ids = get_available_gpus_sorted_by_lru(r, exclude_unauthorized=True)
    
    if len(available_gpu_ids) < count:
        return None
    
    # Get list of GPUs that are in use without reservation for additional validation
    actual_usage = detect_gpu_usage()
    unauthorized_gpus = []
    for gpu_id, usage_info in actual_usage.items():
        if usage_info.get('in_use', False):
            key = f'{REDIS_KEY_PREFIX}gpu:{gpu_id}'
            data = r.get(key)
            if data:
                entry = json.loads(data)
                if not entry or not is_gpu_reserved(entry, now):
                    unauthorized_gpus.append(str(gpu_id))
            else:
                unauthorized_gpus.append(str(gpu_id))
    
    # Try to reserve GPUs in LRU order
    for gpu_id in available_gpu_ids:
        if len(reserved) >= count:
            break
            
        key = f'{REDIS_KEY_PREFIX}gpu:{gpu_id}'
        
        # Enhanced Lua script that checks unauthorized usage list
        lua_script = """
        local key = KEYS[1]
        local gpu_id = KEYS[2]
        local data = redis.call("get", key)
        local now = tonumber(ARGV[1])
        local reservation = ARGV[2]
        local unauthorized_list = cjson.decode(ARGV[3])
        
        -- Check if this GPU is in the unauthorized usage list
        for i, unauthorized_gpu in ipairs(unauthorized_list) do
            if unauthorized_gpu == gpu_id then
                return 0  -- Don't reserve unauthorized GPUs
            end
        end
        
        if not data or data == '{}' then
            redis.call("set", key, reservation)
            return 1
        else
            local entry = cjson.decode(data)
            
            -- Check if reservation is expired
            local expired = false
            if entry.expiry_time and now > entry.expiry_time then
                expired = true
            elseif entry.last_heartbeat and (now - entry.last_heartbeat > 900) then
                expired = true
            elseif not entry.user then
                expired = true
            end
            
            if expired then
                redis.call("set", key, reservation)
                return 1
            else
                return 0
            end
        end
        """
        
        unauthorized_json = json.dumps(unauthorized_gpus)
        if r.eval(lua_script, 2, key, str(gpu_id), now, reservation_json, unauthorized_json):
            reserved.append(gpu_id)
    
    # If we couldn't get enough GPUs, rollback and return None
    if len(reserved) < count:
        rollback_reservations(r, reserved)
        return None
    
    return reserved


def is_gpu_reserved(entry, current_time):
    """Check if a GPU is currently reserved."""
    if not entry or not entry.get('user'):
        return False
    
    # Check expiry time for manual reservations
    if entry.get('expiry_time'):
        return current_time < entry['expiry_time']
    
    # Check heartbeat for run-type reservations
    hb = entry.get('last_heartbeat')
    if hb and current_time - hb <= 900:  # 15 minutes
        return True
    
    return False


def reserve_gpus_manual(r, count, user, duration_seconds):
    """Reserve GPUs manually for a specified duration."""
    expiry_time = now_ts() + duration_seconds
    return atomic_reserve_gpus(r, count, user, 'manual', expiry_time)


def heartbeat(r, gpu_ids, user):
    while True:
        for gpu_id in gpu_ids:
            key = f'{REDIS_KEY_PREFIX}gpu:{gpu_id}'
            r.set(key, json.dumps({
                'user': user,
                'start_time': now_ts(),
                'last_heartbeat': now_ts()
            }))
        time.sleep(60)


@cli.command(context_settings=dict(ignore_unknown_options=True, allow_extra_args=True))
@click.option('--gpus', default=1, type=int, help='Number of GPUs to reserve')
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
def run(gpus, args):
    """Reserve GPUs and run a command with CUDA_VISIBLE_DEVICES set.
    
    Example: canhazgpu run --gpus 2 -- python train.py
    """
    if '--' not in sys.argv:
        click.echo("Error: must separate command with --", err=True)
        sys.exit(1)

    cmd_index = sys.argv.index('--') + 1
    command = sys.argv[cmd_index:]
    if not command:
        click.echo("Error: no command to run", err=True)
        sys.exit(1)

    r = get_redis()
    user = get_username()
    
    # Generate unique lock ID for this process
    lock_id = f"{user}:{os.getpid()}:{now_ts()}"
    
    # Acquire global allocation lock
    if not acquire_allocation_lock(r, lock_id):
        click.echo("Error: Could not acquire allocation lock after retries", err=True)
        sys.exit(1)
    
    try:
        # Atomically reserve GPUs
        gpu_ids = atomic_reserve_gpus(r, gpus, user)
        if not gpu_ids:
            # Provide detailed error message about availability
            available_count = len(get_available_gpus_sorted_by_lru(r, exclude_unauthorized=True))
            total_available = len(get_available_gpus_sorted_by_lru(r, exclude_unauthorized=False))
            unauthorized_count = total_available - available_count
            
            error_msg = f"Error: Not enough GPUs available. Requested: {gpus}, Available: {available_count}"
            if unauthorized_count > 0:
                error_msg += f" ({unauthorized_count} GPUs in use without reservation - run 'canhazgpu status' for details)"
            
            click.echo(error_msg, err=True)
            sys.exit(1)
    finally:
        # Always release the allocation lock
        release_allocation_lock(r, lock_id)

    os.environ['CUDA_VISIBLE_DEVICES'] = ','.join(map(str, gpu_ids))
    click.echo(f"Running with GPUs: {os.environ['CUDA_VISIBLE_DEVICES']}")

    hb_thread = threading.Thread(target=heartbeat, args=(r, gpu_ids, user), daemon=True)
    hb_thread.start()

    try:
        result = subprocess.run(command)
        sys.exit(result.returncode)
    finally:
        # Clean up GPU reservations
        rollback_reservations(r, gpu_ids)
        click.echo("Released GPUs.")


@cli.command()
@click.option('--gpus', default=1, type=int, help='Number of GPUs to reserve')
@click.option('--duration', default='8h', help='Duration to reserve GPUs (e.g., 2h, 30m, 1d)')
def reserve(gpus, duration):
    """Reserve GPUs manually for a specified duration.
    
    Examples:
        canhazgpu reserve --gpus 2 --duration 4h
        canhazgpu reserve --duration 30m
        canhazgpu reserve --gpus 1 --duration 2d
    """
    try:
        duration_seconds = parse_duration(duration)
    except click.BadParameter as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)
    
    r = get_redis()
    user = get_username()
    
    # Generate unique lock ID for this process
    lock_id = f"{user}:{os.getpid()}:{now_ts()}"
    
    # Acquire global allocation lock
    if not acquire_allocation_lock(r, lock_id):
        click.echo("Error: Could not acquire allocation lock after retries", err=True)
        sys.exit(1)
    
    try:
        # Atomically reserve GPUs
        gpu_ids = reserve_gpus_manual(r, gpus, user, duration_seconds)
        if not gpu_ids:
            # Provide detailed error message about availability
            available_count = len(get_available_gpus_sorted_by_lru(r, exclude_unauthorized=True))
            total_available = len(get_available_gpus_sorted_by_lru(r, exclude_unauthorized=False))
            unauthorized_count = total_available - available_count
            
            error_msg = f"Error: Not enough GPUs available. Requested: {gpus}, Available: {available_count}"
            if unauthorized_count > 0:
                error_msg += f" ({unauthorized_count} GPUs in use without reservation - run 'canhazgpu status' for details)"
            
            click.echo(error_msg, err=True)
            sys.exit(1)
    finally:
        # Always release the allocation lock
        release_allocation_lock(r, lock_id)
    
    expiry_time = now_ts() + duration_seconds
    click.echo(f"Reserved {len(gpu_ids)} GPU(s) {gpu_ids} for {duration} ({format_expiry_time(expiry_time)})")


@cli.command()
def release():
    """Release all manually reserved GPUs held by the current user.
    
    Example: canhazgpu release
    """
    r = get_redis()
    user = get_username()
    gpu_count = int(r.get(f'{REDIS_KEY_PREFIX}gpu_count') or 0)
    released = []
    
    for gpu_id in range(gpu_count):
        key = f'{REDIS_KEY_PREFIX}gpu:{gpu_id}'
        data = r.get(key)
        if data:
            entry = json.loads(data)
            if (entry and 
                entry.get('user') == user and 
                entry.get('type') == 'manual'):
                r.set(key, json.dumps({}))
                released.append(gpu_id)
    
    if released:
        click.echo(f"Released {len(released)} GPU(s): {released}")
    else:
        click.echo("No manually reserved GPUs found for current user")


if __name__ == '__main__':
    cli()
